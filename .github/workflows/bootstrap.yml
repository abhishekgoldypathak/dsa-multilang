name: Auto Boilerplate Setup

on:
  create:
    branches:
      - "course*"

jobs:
  create_boilerplate:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/heads/course')
    steps:
      - name: Checkout the new branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}

      - name: Extract branch name
        id: vars
        run: echo "branch_name=${GITHUB_REF#refs/heads/}" >> $GITHUB_ENV

      - name: Create boilerplate if missing
        run: |
          BASE_DIR="coursera/${{ env.branch_name }}"
          if [ ! -d "$BASE_DIR" ]; then
            echo "Creating boilerplate for $BASE_DIR..."
            mkdir -p "$BASE_DIR"/{c,cpp,golang,python}

            cat <<'EOF' > "$BASE_DIR/c/main.c"
#include <stdio.h>

int main() {
    printf("Hello, C from ${BRANCH_NAME}!\n");
    return 0;
}
EOF

            cat <<'EOF' > "$BASE_DIR/c/Makefile"
all: main
main: main.c
\tgcc main.c -o main
clean:
\trm -f main
EOF

            cat <<'EOF' > "$BASE_DIR/cpp/CMakeLists.txt"
cmake_minimum_required(VERSION 3.10)
project(DSA_CPP)
set(CMAKE_CXX_STANDARD 17)
add_executable(main main.cpp)
EOF

            cat <<'EOF' > "$BASE_DIR/cpp/main.cpp"
#include <iostream>
int main() {
    std::cout << "Hello, C++ from ${BRANCH_NAME}!" << std::endl;
    return 0;
}
EOF

            cat <<'EOF' > "$BASE_DIR/golang/main.go"
package main
import "fmt"
func main() {
    fmt.Println("Hello, Go from ${BRANCH_NAME}!")
}
EOF
